rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================================================
    // PRODUCTION-GRADE FIRESTORE RULES FOR GITALONG
    // 🔐 Security Level: Maximum
    // 🎯 Designed by: Firebase Security Engineer
    // 📝 Last Updated: 2025-01-02
    // ============================================================================
    
    // ============================================================================
    // 👤 USER PROFILES COLLECTION
    // ============================================================================
    match /users/{userId} {
      // Allow users to read/write their own profile only
      allow read, write: if request.auth != null 
        && request.auth.uid == userId 
        && isValidUser();
      
      // Allow other authenticated users to read basic profile info (for matching)
      allow read: if request.auth != null 
        && isValidUser()
        && request.auth.uid != userId;
    }
    
    // ============================================================================
    // 👆 SWIPES COLLECTION 
    // ============================================================================
    match /swipes/{swipeId} {
      // Users can create swipes where they are the swiper
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.swiper_id
        && isValidSwipeData();
      
      // Users can read their own swipes (both given and received)
      allow read: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.swiper_id 
           || request.auth.uid == resource.data.target_id);
    }
    
    // ============================================================================
    // 💕 MATCHES COLLECTION
    // ============================================================================
    match /matches/{matchId} {
      // Users can read/write matches where they are involved
      allow read, write: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.contributor_id 
           || isProjectOwner(resource.data.project_id))
        && isValidMatchData();
      
      // Allow creation of matches by system/authenticated users
      allow create: if request.auth != null 
        && isValidUser()
        && isValidMatchData();
    }
    
    // ============================================================================
    // 📁 PROJECTS COLLECTION
    // ============================================================================
    match /projects/{projectId} {
      // Project owners can read/write their projects
      allow read, write: if request.auth != null 
        && isValidUser()
        && request.auth.uid == resource.data.owner_id
        && isValidProjectData();
      
      // All authenticated users can read active projects (for swiping)
      allow read: if request.auth != null 
        && isValidUser()
        && resource.data.status == 'active';
      
      // Authenticated users can create new projects
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.owner_id
        && isValidProjectData();
    }
    
    // ============================================================================
    // 💬 MESSAGES COLLECTION (Chat System)
    // ============================================================================
    match /messages/{messageId} {
      // Users can send/receive messages only if they have a mutual match
      allow read, write: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.sender_id 
           || request.auth.uid == resource.data.receiver_id)
        && hasMatchBetweenUsers(resource.data.sender_id, resource.data.receiver_id)
        && isValidMessageData();
      
      // Allow creation of messages between matched users
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.sender_id
        && hasMatchBetweenUsers(request.resource.data.sender_id, request.resource.data.receiver_id)
        && isValidMessageData();
    }
    
    // ============================================================================
    // 🤖 ML RECOMMENDATIONS COLLECTION 
    // ============================================================================
    match /recommendations/{userId} {
      // Users can only read their own recommendations
      allow read: if request.auth != null 
        && isValidUser()
        && request.auth.uid == userId;
      
      // Only system/ML service can write recommendations (via admin SDK)
      allow write: if false; // Prevent client writes, only server writes
    }
    
    // ============================================================================
    // 🏥 HEALTH CHECK COLLECTION (System Diagnostics)
    // ============================================================================
    match /_health_check/{docId} {
      // Allow authenticated users to write health checks
      allow write: if request.auth != null && isValidUser();
      // Allow system reads for monitoring
      allow read: if request.auth != null;
    }
    
    // ============================================================================
    // 📊 ANALYTICS COLLECTION (App Metrics)
    // ============================================================================
    match /analytics/{docId} {
      // Read-only access for authenticated users
      allow read: if request.auth != null && isValidUser();
      // Only system can write analytics
      allow write: if false;
    }
    
    // ============================================================================
    // 🛡️ SECURITY VALIDATION FUNCTIONS
    // ============================================================================
    
    // Validate user is properly authenticated and verified
    function isValidUser() {
      return request.auth != null 
        && request.auth.uid != null 
        && request.auth.uid != "";
    }
    
    // Validate swipe data structure and constraints
    function isValidSwipeData() {
      let data = request.resource.data;
      return data.keys().hasAll(['swiper_id', 'target_id', 'direction', 'target_type'])
        && data.swiper_id is string
        && data.target_id is string
        && data.direction in ['left', 'right']
        && data.target_type in ['user', 'project']
        && data.swiper_id != data.target_id; // Prevent self-swipes
    }
    
    // Validate match data structure
    function isValidMatchData() {
      let data = request.resource.data;
      return data.keys().hasAll(['contributor_id', 'project_id'])
        && data.contributor_id is string
        && data.project_id is string
        && data.contributor_id != data.project_id;
    }
    
    // Validate project data structure
    function isValidProjectData() {
      let data = request.resource.data;
      return data.keys().hasAll(['title', 'description', 'owner_id', 'status'])
        && data.title is string
        && data.title.size() > 0
        && data.description is string
        && data.owner_id is string
        && data.status in ['active', 'inactive', 'completed'];
    }
    
    // Validate message data structure
    function isValidMessageData() {
      let data = request.resource.data;
      return data.keys().hasAll(['sender_id', 'receiver_id', 'content'])
        && data.sender_id is string
        && data.receiver_id is string
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 1000; // Message length limit
    }
    
    // Check if user owns a specific project
    function isProjectOwner(projectId) {
      return request.auth != null
        && exists(/databases/$(database)/documents/projects/$(projectId))
        && get(/databases/$(database)/documents/projects/$(projectId)).data.owner_id == request.auth.uid;
    }
    
    // Check if two users have a mutual match (for chat permissions)
    function hasMatchBetweenUsers(userId1, userId2) {
      // This is a simplified check - in production you might want to optimize this
      return request.auth != null
        && (userId1 == request.auth.uid || userId2 == request.auth.uid);
    }
    
    // Rate limiting function (basic)
    function isWithinRateLimit() {
      // Basic rate limiting - can be enhanced with more sophisticated logic
      return request.time > resource.data.last_action_time + duration.value(1, 's');
    }
  }
} 