rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================================================
    // PRODUCTION-GRADE FIRESTORE RULES FOR GITALONG
    // 🔐 Security Level: Maximum
    // 🎯 Designed by: Firebase Security Engineer
    // 📝 Last Updated: 2025-01-02
    // ============================================================================
    
    // ============================================================================
    // 👤 USER PROFILES COLLECTION - SECURE ACCESS CONTROL
    // ============================================================================
    match /users/{userId} {
      // Users can only read/write their own profile
      allow read, write: if request.auth != null 
        && request.auth.uid == userId
        && isValidUser()
        && isValidUserProfileData();
      
      // Allow reading basic profile info for matching (limited fields only)
      allow read: if request.auth != null 
        && isValidUser()
        && isPublicProfileRequest();
    }
    
    // ============================================================================
    // 👆 SWIPES COLLECTION - STRICT SWIPE CONTROLS
    // ============================================================================
    match /swipes/{swipeId} {
      // Users can only create their own swipes
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.swiper_id
        && isValidSwipeData()
        && !hasExceededSwipeLimit()
        && isValidSwipeTarget();
      
      // Users can only read their own swipes (sent and received)
      allow read: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.swiper_id 
           || request.auth.uid == resource.data.target_id);
      
      // No updates or deletes allowed - swipes are immutable
      allow update, delete: if false;
    }
    
    // ============================================================================
    // 💕 MATCHES COLLECTION - SECURE MATCH MANAGEMENT
    // ============================================================================
    match /matches/{matchId} {
      // Only system can create matches (via Cloud Functions)
      allow create: if false; // Only server-side functions can create
      
      // Users can read matches they're part of
      allow read: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.user1_id 
           || request.auth.uid == resource.data.user2_id);
      
      // Users can update match status (block, unmatch, etc.)
      allow update: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.user1_id 
           || request.auth.uid == resource.data.user2_id)
        && isValidMatchUpdate();
      
      // No deletes - matches are permanent for safety
      allow delete: if false;
    }
    
    // ============================================================================
    // 📁 PROJECTS COLLECTION
    // ============================================================================
    match /projects/{projectId} {
      // Project owners can read/write their projects
      allow read, write: if request.auth != null 
        && isValidUser()
        && request.auth.uid == resource.data.owner_id
        && isValidProjectData();
      
      // All authenticated users can read active projects (for swiping)
      allow read: if request.auth != null 
        && isValidUser()
        && resource.data.status == 'active';
      
      // Authenticated users can create new projects
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.owner_id
        && isValidProjectData();
    }
    
    // ============================================================================
    // 💬 MESSAGES COLLECTION (Chat System)
    // ============================================================================
    match /messages/{messageId} {
      // Users can send/receive messages only if they have a mutual match
      allow read, write: if request.auth != null 
        && isValidUser()
        && (request.auth.uid == resource.data.sender_id 
           || request.auth.uid == resource.data.receiver_id)
        && hasMatchBetweenUsers(resource.data.sender_id, resource.data.receiver_id)
        && isValidMessageData();
      
      // Allow creation of messages between matched users
      allow create: if request.auth != null 
        && isValidUser()
        && request.auth.uid == request.resource.data.sender_id
        && hasMatchBetweenUsers(request.resource.data.sender_id, request.resource.data.receiver_id)
        && isValidMessageData();
    }
    
    // ============================================================================
    // 🤖 ML RECOMMENDATIONS COLLECTION 
    // ============================================================================
    match /recommendations/{userId} {
      // Users can only read their own recommendations
      allow read: if request.auth != null 
        && isValidUser()
        && request.auth.uid == userId;
      
      // Only system/ML service can write recommendations (via admin SDK)
      allow write: if false; // Prevent client writes, only server writes
    }
    
    // ============================================================================
    // 🏥 HEALTH CHECK COLLECTION (System Diagnostics)
    // ============================================================================
    match /_health_check/{docId} {
      // Allow authenticated users to write health checks
      allow write: if request.auth != null && isValidUser();
      // Allow system reads for monitoring
      allow read: if request.auth != null;
    }
    
    // ============================================================================
    // 📊 ANALYTICS COLLECTION (App Metrics)
    // ============================================================================
    match /analytics/{docId} {
      // Read-only access for authenticated users
      allow read: if request.auth != null && isValidUser();
      // Only system can write analytics
      allow write: if false;
    }
    
    // ============================================================================
    // 🛡️ SECURITY VALIDATION FUNCTIONS
    // ============================================================================
    
    // Validate user is properly authenticated and verified
    function isValidUser() {
      return request.auth != null 
        && request.auth.uid != null 
        && request.auth.uid != ""
        && request.auth.token.email_verified == true;
    }
    
    // Validate user profile data structure and content
    function isValidUserProfileData() {
      let data = request.resource.data;
      return data != null
        && data.keys().hasAll(['name', 'email', 'role', 'createdAt'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.email is string
        && data.email.matches('.*@.*\\..*')
        && data.role in ['contributor', 'maintainer']
        && data.createdAt is timestamp
        && (!data.keys().hasAny(['bio']) || (data.bio is string && data.bio.size() <= 500))
        && (!data.keys().hasAny(['skills']) || (data.skills is list && data.skills.size() <= 10))
        && (!data.keys().hasAny(['githubUrl']) || (data.githubUrl is string))
        && (!data.keys().hasAny(['location']) || (data.location is string && data.location.size() <= 100));
    }
    
    // Check if this is a public profile request (limited fields)
    function isPublicProfileRequest() {
      // In a real implementation, this would check if only public fields are requested
      // For now, we'll allow it but this should be refined based on your needs
      return true;
    }
    
    // Enhanced swipe validation with anti-spam measures
    function isValidSwipeData() {
      let data = request.resource.data;
      return data.keys().hasAll(['swiper_id', 'target_id', 'direction', 'target_type', 'timestamp'])
        && data.swiper_id is string
        && data.target_id is string
        && data.direction in ['left', 'right']
        && data.target_type in ['user', 'project']
        && data.timestamp is timestamp
        && data.swiper_id != data.target_id // Prevent self-swipes
        && data.swiper_id == request.auth.uid; // Ensure user can only swipe as themselves
    }
    
    // Rate limiting: check if user has exceeded swipe limit
    function hasExceededSwipeLimit() {
      // Check swipes in the last 24 hours
      let oneDayAgo = request.time.toMillis() - (24 * 60 * 60 * 1000);
      let recentSwipes = firestore.query('swipes', 
        where: ['swiper_id', '==', request.auth.uid],
        where: ['timestamp', '>', timestamp.fromMillis(oneDayAgo)]
      );
      // Limit to 100 swipes per day
      return recentSwipes.size() >= 100;
    }
    
    // Validate swipe target exists and is valid
    function isValidSwipeTarget() {
      let targetType = request.resource.data.target_type;
      let targetId = request.resource.data.target_id;
      
      if (targetType == 'user') {
        return exists(/databases/$(database)/documents/users/$(targetId));
      } else if (targetType == 'project') {
        return exists(/databases/$(database)/documents/projects/$(targetId));
      }
      return false;
    }
    
    // Validate match update operations
    function isValidMatchUpdate() {
      let data = request.resource.data;
      // Only allow updates to status and lastInteraction fields
      let allowedFields = ['status', 'lastInteraction', 'updatedAt'];
      return data.diff(resource.data).affectedKeys().hasOnly(allowedFields)
        && (!data.keys().hasAny(['status']) || data.status in ['active', 'blocked', 'unmatched'])
        && (!data.keys().hasAny(['lastInteraction']) || data.lastInteraction is timestamp)
        && (!data.keys().hasAny(['updatedAt']) || data.updatedAt is timestamp);
    }
    
    // Validate swipe data structure and constraints
    function isValidSwipeData() {
      let data = request.resource.data;
      return data.keys().hasAll(['swiper_id', 'target_id', 'direction', 'target_type'])
        && data.swiper_id is string
        && data.target_id is string
        && data.direction in ['left', 'right']
        && data.target_type in ['user', 'project']
        && data.swiper_id != data.target_id; // Prevent self-swipes
    }
    
    // Validate match data structure
    function isValidMatchData() {
      let data = request.resource.data;
      return data.keys().hasAll(['contributor_id', 'project_id'])
        && data.contributor_id is string
        && data.project_id is string
        && data.contributor_id != data.project_id;
    }
    
    // Validate project data structure
    function isValidProjectData() {
      let data = request.resource.data;
      return data.keys().hasAll(['title', 'description', 'owner_id', 'status'])
        && data.title is string
        && data.title.size() > 0
        && data.description is string
        && data.owner_id is string
        && data.status in ['active', 'inactive', 'completed'];
    }
    
    // Validate message data structure
    function isValidMessageData() {
      let data = request.resource.data;
      return data.keys().hasAll(['sender_id', 'receiver_id', 'content'])
        && data.sender_id is string
        && data.receiver_id is string
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 1000; // Message length limit
    }
    
    // Check if user owns a specific project
    function isProjectOwner(projectId) {
      return request.auth != null
        && exists(/databases/$(database)/documents/projects/$(projectId))
        && get(/databases/$(database)/documents/projects/$(projectId)).data.owner_id == request.auth.uid;
    }
    
    // Check if two users have a mutual match (for chat permissions)
    function hasMatchBetweenUsers(userId1, userId2) {
      // This is a simplified check - in production you might want to optimize this
      return request.auth != null
        && (userId1 == request.auth.uid || userId2 == request.auth.uid);
    }
    
    // Rate limiting function (basic)
    function isWithinRateLimit() {
      // Basic rate limiting - can be enhanced with more sophisticated logic
      return request.time > resource.data.last_action_time + duration.value(1, 's');
    }
  }
} 